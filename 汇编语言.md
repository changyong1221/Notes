# 汇编语言

### 1. ascii码和扫描码

   字符a:   61h	1Eh

   字符A:	41h	1Eh

   总结：ascii码区分大小写，而扫描码不区分，实际上扫描码与键盘上的按键存在一一对应关系。

### 2. CL指令：

   将寄存器DX中的数左移（CL）位。 比如CL为2，就是向左移2位
   左移N位，就是将原来的数乘以2的N次方

### 3. div指令：

   当除数是字节 也就是8位的时候  被除数必须是16位  被除数存放在ax寄存器中  除数放在bl中

   除到得 结果是 商是8位放在al中 余数放在ah中

   例子

   mov ax,0006h

   mov bl,02h

   div bl

   使用debug调试时 查看结果

   执行div bl

   查看ax的结果是 0003

   可看出 ah=00

   al=03

   商是3 余数是0

   

   当除数是字 也就是16位的时候  被除数必须是32位  被除数低16位存放在ax寄存器中 ，高16位放在dx寄存器中  

   除到得 结果是 商是16位放在ax中 余数放在dx中

   

    mov dx,0001h
    mov ax,83a1h  
    mov bx,0064h  
    div bx 

### 4. 从键盘读字符

   mov ah, 0

   int 16h

   表示从键盘读字符,int 16h是基本键盘操作中断，ah存放功能号0，表示从键盘读字符

   **注意：in al, 60h 和 mov ah, 0 int 16h的区别**

   x86中,port60h是键盘端口
   in al,60h读入的是一个0-255的扫瞄码,但只是侦查了最后一个按键,一天前按的键,只要没有按第二个键,
   in al,60h仍是那个码,in al,60h并不清除键盘缓冲,端口的按键不会因为你in了后消失,若没有再按新键,
   in 一万次,al仍是那个码值.
   假若有人输入了abcde, in al,60时,并不能太准码的5次可以读完abcde,可能是3次读到a,再4次读到b,2次读到c,
   5次读到d,然后无限次读到c...这要看输入时按者的速度和cpu的反应力.
   即使全in了,abcde仍旧放在键盘缓冲,其他程式仍可以读取.

   mov ah,0
   int 16h
   就是程式停在那里,不做动作,直到有人按了键,然后中断才返回.
   读入的ah是扫瞄码,al是ascii码
   int 16h完了后,键盘缓冲的键被读走,接后的[键排伍] 挪前....

   ```assembly
   assume cs:code, ds:data, ss:stack
   
   stack segment
       db 1024 dup (0)
   stack ends
   
   data segment
       ;          Q   W   E   R   T   Y   U   A   S   D   F   G   H   J   Z   X   C   V   B   N   M
       keytab dw 524,587,659,698,784,880,988,261,294,329,349,392,440,494,131,147,165,175,196,220,247  
       dw 0,0
       welc db 'Welcome!', 0dh, 0ah, '$'
       home db 'Press', 0dh, 0ah, '$'
       un_home db 'Unpress', 0dh, 0ah, '$'
   data ends
   
   code segment
   start:
       mov ax, stack
       mov ss, ax
       mov sp, 128
       mov ax, data
       mov ds, ax      ; 初始化数据区
       
       lea dx, welc
       mov ah, 9       ; 与 int 21h 合用，用于屏幕显示
       int 21h         ; 显示提示语句
       
       ; 改中断例程入口地址
       mov ax,0
       mov es,ax
       push es:[9*4]
       pop ds:[0]
       push es:[9*4+2]
       pop ds:[2]
       mov word ptr es:[9*4],offset int9
       mov es:[9*4+2],cs
   
   run:
       mov ah, 9
       int 16h
       jmp run         ; 写个死循环，调用int9中断
       
       ; 定义中断例程
   int9:
       push ax
       push bx
       push es
       in al,60h
       pushf
       pushf
       pop bx
       and bh,11111100b
       push bx
       popf
       call dword ptr ds:[0]
         
   keydown_high:
       cmp al, 010h
       jb press_esc
       cmp al, 016h
       ja keydown_mid
       lea dx, home
       mov ah, 9
       int 21h
       mov dl, al
       add dl, 080h
       jmp int9ret
   
   keydown_mid:
       cmp al, 01Eh
       jb int9ret
       cmp al, 024h
       ja keydown_low
       lea dx, home
       mov ah, 9
       int 21h
       mov dl, al
       add dl, 080h
       jmp int9ret
   
   keydown_low:
       cmp al, 02Ch
       jb int9ret
       cmp al, 032h
       ja keyup_high
       lea dx, home
       mov ah, 9
       int 21h
       mov dl, al
       add dl, 080h
       jmp int9ret
              
   keyup_high:
       cmp al, dl
       jne int9ret
       lea dx, un_home
       mov ah, 9
       int 21h
       jmp int9ret         
   
   press_esc:
       cmp al, 01h ;01h是Esc键的扫描码
       jne int9ret
       ;使程序结束，注意在此要恢复中断向量
       mov ax,0
       mov es,ax
       
       push ds:[0]
       pop es:[9*4]
       push ds:[2]
       pop es:[9*4+2]
       
       mov ax,4c00h
       int 21h
           
   int9ret:
       pop es
       pop bx
       pop ax
       iret
             
   code ends
   end start
   ```

   

### 5. 退出程序

   exit:
       mov ah, 4ch
       int 21h         ; 退出程序

### 6. 顺序执行

   fun:

   fun1:

   fun2:

   ret

   在fun内，fun1和fun2是顺序执行的，并不是if else关系。

### 7. 初始化数据区

       mov ax, data
       mov ds, ax      ; 初始化数据区

### 8. 显示数据段

       lea dx, welc
       mov ah, 9       ; 与 int 21h 合用，用于屏幕显示
       int 21h         ; 显示提示语句

### 9. int指令

   int指令可以引发中断
   int指令格式：int n，n为中断类型码，它的功能是引发中断过程。

   CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下：

   取中断类型码n
   标志寄存器入栈，IF=0、TF=0
   CS、IP入栈
   (IP)=(n∗4),(CS)=(n∗4+2)(IP)=(n∗4),(CS)=(n∗4+2)

### 10. int 9键盘中断

汇编编写新的INT9中断为什么还要调用原来的int9?

    在王爽老师的书中有一节是要编写新的INT9我先说下我的理解，当我们在键盘按下'a'时，机器将扫描码发送至 60H端口，并向CPU发出IN9中断请求，我是把int9的入口[9*4]和[9*4+2]改成0：7E00H ，并在这里写改变屏幕颜色的程序，那就能达到，我在键盘按下a键，发出int9中断，调到0:7E00H执行我的程序，但实际上一定要在我的程序前call调用原理的INT9才能完成，请大神指教

### 11. int 1ah：时钟服务

    ```assembly
    功能号：00H
    
    功能： 读取时钟“滴答”计数
    入口参数：AH＝00H
    出口参数：AL＝00H—未过午夜，否则，表示已过午夜
             CX:DX＝时钟“滴答”计数
    
    功能号：01H
    
    功能：设置时钟“滴答”计数
    入口参数：AH＝01H
             CX:DX＝时钟“滴答”计数
    出口参数：无
    
    功能号：02H
    
    功能：读取时间
    入口参数：AH＝02H
    出口参数：CH＝BCD码格式的小时
             CL＝BCD码格式的分钟
             DH＝BCD码格式的秒
             DL＝00H—标准时间，否则，夏令时
             CF＝0—时钟在走，否则，时钟停止
    
    功能号：03H
    
    功能： 设置时间
    入口参数：AH＝03H
             CH＝BCD码格式的小时
             CL＝BCD码格式的分钟
             DH＝BCD码格式的秒
             DL＝00H—标准时间，否则，夏令时
    出口参数： 无
    
    功能号：04H
    
    功能：读取日期
    入口参数：AH＝04H
    出口参数：CH＝BCD码格式的世纪
             CL＝BCD码格式的年
             DH＝BCD码格式的月
             DL＝BCD码格式的日
             CF＝0—时钟在走，否则，时钟停止
    
    功能号：05H
    
    功能：设置日期
    入口参数：AH＝05H
             CH＝BCD码格式的世纪
             CL＝BCD码格式的年
             DH＝BCD码格式的月
             DL＝BCD码格式的日
    出口参数： 无
    
    功能号：06H
    
    功能：设置闹钟
    入口参数：AH＝06H
             CH＝BCD码格式的小时
             CL＝BCD码格式的分钟
             DH＝BCD码格式的秒
    出口参数： CF＝0—操作成功，否则，闹钟已设置或时钟已停止
    
    功能号：07H
    
    功能：闹钟复位
    入口参数：AH＝07H
    出口参数：无
    
    功能号：0AH
    
    功能：读取天数计数，仅在PS/2有效，在此从略
    
    功能号：0BH
    
    功能：设置天数计数，仅在PS/2有效，在此从略
    
    功能号：80H
    
    功能描述：设置声音源信息
    入口参数：AH ＝80H
             AL ＝声音源
                ＝00H——8253可编程计时器，通道2
                ＝01H——盒式磁带输入
                ＝02H——I/O通道上的"Audio In"
                ＝03H——声音产生芯片
    
    出口参数： 无
    ```

### 12. 汇编 db,dw,dd的区别

    ```
    db定义字节类型变量，一个字节数据占1个字节单元，读完一个，偏移量加1
    dw定义字类型变量，一个字数据占2个字节单元，读完一个，偏移量加2
    dd定义双字类型变量，一个双字数据占4个字节单元，读完一个，偏移量加4
    ```

### 13. in al,61h

    把外部端口61h的数据送到al中。

### 14. 钢琴程序

    方法一（新定义int9键盘中断例程）：
    
    ```assembly
    assume cs:code, ds:data, ss:stack
    
    stack segment
        db 1024 dup (0)
    stack ends
    
    data segment
        ;          Q   W   E   R   T   Y   U   A   S   D   F   G   H   J   Z   X   C   V   B   N   M
        keytab dw 524,587,659,698,784,880,988,261,294,329,349,392,440,494,131,147,165,175,196,220,247  
        welc db 'Welcome!', 0dh, 0ah, '$'
        home db 'Press', 0dh, 0ah, '$'
        un_home db 'Unpress', 0dh, 0ah, '$'
    data ends
    
    code segment
    start:
        mov ax, stack
        mov ss, ax
        mov sp, 128
        mov ax, data
        mov ds, ax      ;初始化数据区


​        
    loops:              ;循环读取输入
        in al,60h       ;读取键盘输入   
        cmp al,1Eh
        jnz off
        ;-------------------------
        mov al,0
        mov ah,0
        add ax,ax        
        lea si,keytab
        add si,ax
        mov bx,[si] ;频率
        
        mov dx,12h   ;dx放被除数高16位
        mov ax,2870h ;ax放被除数低16位
        div bx  
        mov bx,ax ;将商存入bx中 
        
        in al,61h
        mov ah,al  ;把61h的原状态值交由ah暂存
        or al, 00000011b
        out 61h,al
        
        mov al,0b6h ;8254的2号定时器初始化
        out 43h,al
        mov al,bl  ;先送商的低字节到42h
        out 42h,al
        mov al,bh  ;再送商的高字节到42h
        out 42h,al
    
        ;------------------------  
    
    off:
        cmp al,9Eh
        jnz hello
        in al,61h
        and al,11111100B
        out 61h,al	;off
        
    hello:
        lea dx, welc
        mov ah, 9       ; 与 int 21h 合用，用于屏幕显示
        int 21h         ; 显示提示语句
        
        jmp loops
        ; 改中断例程入口地址
        mov ax,0
        mov es,ax
        push es:[9*4]
        pop ds:[0]
        push es:[9*4+2]
        pop ds:[2]
        mov word ptr es:[9*4],offset int9
        mov es:[9*4+2],cs
        
    run:
        jmp run         ; 写个死循环，调用int9中断
        
        ; 定义中断例程
    int9:
        push ax
        push bx
        push es
        in al,60h
        pushf
        pushf
        pop bx
        and bh,11111100b
        push bx
        popf
        call dword ptr ds:[0]
          
    keydown_high:
        cmp al, 010h
        jb press_esc
        cmp al, 016h
        ja keydown_mid
        lea dx, home
        mov ah, 9
        int 21h
        mov dl, al
        add dl, 080h
        jmp int9ret
    
    keydown_mid:
        cmp al, 01Eh
        jb int9ret
        cmp al, 024h
        ja keydown_low
        lea dx, home
        mov ah, 9
        int 21h
        mov dl, al
        add dl, 080h
        jmp int9ret
    
    keydown_low:
        cmp al, 02Ch
        jb int9ret
        cmp al, 032h
        ja keyup_high
        lea dx, home
        mov ah, 9
        int 21h
        mov dl, al
        add dl, 080h
        jmp int9ret
               
    keyup_high:
        cmp al, dl
        jne int9ret
        lea dx, un_home
        mov ah, 9
        int 21h
        jmp int9ret         
    
    press_esc:
        cmp al, 01h ;01h是Esc键的扫描码
        jne int9ret
        ;使程序结束，注意在此要恢复中断向量
        mov ax,0
        mov es,ax
        
        push ds:[0]
        pop es:[9*4]
        push ds:[2]
        pop es:[9*4+2]
        
        mov ax,4c00h
        int 21h
            
    int9ret:
        pop es
        pop bx
        pop ax
        iret
              
    code ends
    end start
    ```
    
    方法二（loops循环检测 in al,60h）：
    
    ```assembly
    assume cs:code, ds:data, ss:stack
    
    stack segment
        db 1024 dup (0)
    stack ends
    
    data segment
        ;          Q   W   E   R   T   Y   U   A   S   D   F   G   H   J   Z   X   C   V   B   N   M
        keytab dw 524,587,659,698,784,880,988,261,294,329,349,392,440,494,131,147,165,175,196,220,247  
    data ends
    
    code segment
    start:
        mov ax, stack
        mov ss, ax      ;初始化栈区
        mov ax, data
        mov ds, ax      ;初始化数据区
        
    input:              ;循环读取输入
        in al,60h       ;读取键盘输入   
        jmp keydown_high
    
    ;高音区      
    keydown_high:
        cmp al,010h     ;检测是否是Q~U之内的键
        jb press_esc
        cmp al, 016h
        ja keydown_mid
        
        mov dl,al      ;计算并保存按键的断码
        add dl,080h
        
        sub al,010h    ;计算按键对应频率
        mov ah,0
        add ax,ax
        lea si,keytab
        add si,ax
        mov bx,[si]    ;将按键对应频率存入bx
        
        call mysound   ;以指定频率发声
        jmp input
    
    ;中音区
    keydown_mid:
        cmp al, 01Eh   ;检测是否是A~J之内的键
        jb input
        cmp al, 024h
        ja keydown_low
        
        mov dl,al      ;计算并保存按键的断码
        add dl,080h
        
        sub al,01Eh    ;计算按键对应频率
        mov ah,0
        add ax,ax
        add ax,0Eh     ;偏移14个字节
        lea si,keytab
        add si,ax
        mov bx,[si]    ;将按键对应频率存入bx
        
        call mysound   ;以指定频率发声
        jmp input
    
    ;低音区
    keydown_low:
        cmp al, 02Ch   ;检测是否是Z~M之内的键
        jb input
        cmp al, 032h
        ja keyup
        
        mov dl,al      ;计算并保存按键的断码
        add dl,080h
        
        sub al,02Ch    ;计算按键对应频率
        mov ah,0
        add ax,ax
        add ax,01Ch    ;偏移28个字节
        lea si,keytab
        add si,ax
        mov bx,[si]    ;将按键对应频率存入bx
        
        call mysound   ;以指定频率发声
        jmp input
    
    ;按键弹起           
    keyup:
        cmp al,dl      ;如果检测到按键断码,则按键已释放
        jne input
        in al,61h
        and al,11111100B    ;关闭扬声器
        out 61h,al	
        jmp input
    
    ;按下Esc键
    press_esc:
        cmp al,01h ;01h是Esc键的扫描码
        jne input
        
        ;使程序结束
        mov ax,4c00h
        int 21h
    
    mysound proc     
        push ax ;现场保护
        push cx ;现场保护
        push dx ;现场保护
        push si ;现场保护                 
        
        mov dx,12h   ;dx放被除数高16位
        mov ax,2870h ;ax放被除数低16位
        div bx  
        mov bx,ax ;将商存入bx中 
        
        in al,61h       ;将端口61h的数据送到al中
        or al,00000011b ;驱动扬声器发出声音
        out 61h,al
        
        mov al,0b6h ;8254的2号定时器初始化
        out 43h,al
        mov al,bl  ;先送商的低字节到42h
        out 42h,al
        mov al,bh  ;再送商的高字节到42h
        out 42h,al   
        
        pop si  ;现场保护
        pop dx  ;现场保护
        pop cx  ;现场保护
        pop ax  ;现场保护
        ret
    mysound endp
    
    code ends
    end start
    ```

### 15. 键盘扫描码

  
